using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Xunit;

namespace ExcelMapper.Tests;

public class MultiMapTests
{
    [Fact]
    public void ReadRow_MultiMap_ReturnsExpected()
    {
        using var importer = Helpers.GetImporter("MultiMap.xlsx");
        importer.Configuration.RegisterClassMap(new MultiMapRowMap());

        ExcelSheet sheet = importer.ReadSheet();
        sheet.ReadHeading();

        MultiMapRow row1 = sheet.ReadRow<MultiMapRow>();
        Assert.Equal([1, 2, 3], row1.MultiMapName);
        Assert.Equal(new string[] { "a", "b" }, row1.MultiMapIndex);
        Assert.Equal([1, 2], row1.IEnumerableInt);
        Assert.Equal([true, false], row1.ICollectionBool);
        Assert.Equal(["a", "b"], row1.IListString);
        Assert.Equal(new string[] { "1", "2" }, row1.ListString);
        Assert.Equal(new string[] { "1", "2" }, row1._concreteICollection);
        Assert.Equal(new string[] { "1", "2" }, row1.CollectionString);
        Assert.Equal(new string[] { "1", "2" }, row1.ObservableCollectionString);
        Assert.Equal(new string[] { "1", "2" }, row1.CustomObservableCollectionString);
        Assert.Equal(new ObservableCollectionEnum[] { ObservableCollectionEnum.a, ObservableCollectionEnum.b }, row1.CustomObservableCollectionEnum);

        MultiMapRow row2 = sheet.ReadRow<MultiMapRow>();
        Assert.Equal([1, -1, 3], row2.MultiMapName);
        Assert.Equal(new string?[] { null, null }, row2.MultiMapIndex);
        Assert.Equal([0, 0], row2.IEnumerableInt);
        Assert.Equal([false, true], row2.ICollectionBool);
        Assert.Equal(["c", "d"], row2.IListString);
        Assert.Equal(new string[] { "3", "4" }, row2.ListString);
        Assert.Equal(new string[] { "3", "4" }, row2._concreteICollection);
        Assert.Equal(new string[] { "3", "4" }, row2.CollectionString);
        Assert.Equal(new string[] { "3", "4" }, row2.ObservableCollectionString);
        Assert.Equal(new string[] { "3", "4" }, row2.CustomObservableCollectionString);
        Assert.Equal(new ObservableCollectionEnum[] { ObservableCollectionEnum.custom, ObservableCollectionEnum.custom }, row2.CustomObservableCollectionEnum);

        MultiMapRow row3 = sheet.ReadRow<MultiMapRow>();
        Assert.Equal([-1, -1, -1], row3.MultiMapName);
        Assert.Equal(new string?[] { null, "d" }, row3.MultiMapIndex);
        Assert.Equal([5, 6], row3.IEnumerableInt);
        Assert.Equal([false, false], row3.ICollectionBool);
        Assert.Equal(["e", "f"], row3.IListString);
        Assert.Equal(new string[] { "5", "6" }, row3.ListString);
        Assert.Equal(new string[] { "5", "6" }, row3._concreteICollection);
        Assert.Equal(new string[] { "5", "6" }, row3.CollectionString);
        Assert.Equal(new string[] { "5", "6" }, row3.ObservableCollectionString);
        Assert.Equal(new string[] { "5", "6" }, row3.CustomObservableCollectionString);
        Assert.Equal(new ObservableCollectionEnum[] { ObservableCollectionEnum.custom, ObservableCollectionEnum.custom }, row3.CustomObservableCollectionEnum);

        MultiMapRow row4 = sheet.ReadRow<MultiMapRow>();
        Assert.Equal([-2, -2, 3], row4.MultiMapName);
        Assert.Equal(new string?[] { "d", null }, row4.MultiMapIndex);
        Assert.Equal([7, 8], row4.IEnumerableInt);
        Assert.Equal([false, true], row4.ICollectionBool);
        Assert.Equal(["g", "h"], row4.IListString);
        Assert.Equal(new string[] { "7", "8" }, row4.ListString);
        Assert.Equal(new string[] { "7", "8" }, row4._concreteICollection);
        Assert.Equal(new string[] { "7", "8" }, row4.CollectionString);
        Assert.Equal(new string[] { "7", "8" }, row4.ObservableCollectionString);
        Assert.Equal(new string[] { "7", "8" }, row4.CustomObservableCollectionString);
        Assert.Equal(new ObservableCollectionEnum[] { ObservableCollectionEnum.custom, ObservableCollectionEnum.custom }, row4.CustomObservableCollectionEnum);
    }

    private class MultiMapRow
    {
        public int[] MultiMapName { get; set; } = default!;
        public CustomList MultiMapIndex { get; set; } = default!;
        public IEnumerable<int> IEnumerableInt { get; set; } = default!;
        public ICollection<bool> ICollectionBool { get; set; } = default!;
        public IList<string> IListString { get; set; } = default!;
        public List<string> ListString { get; set; } = default!;
        public SortedSet<string> _concreteICollection = default!;
        public Collection<string> CollectionString { get; set; } = default!;
        public ObservableCollection<string> ObservableCollectionString { get; set; } = default!;
        public CustomObservableCollection CustomObservableCollectionString { get; set; } = default!;
        public CustomEnumObservableCollection CustomObservableCollectionEnum { get; set; } = default!;
    }

    private class MultiMapRowMap : ExcelClassMap<MultiMapRow>
    {
        public MultiMapRowMap()
        {
            Map(p => p.MultiMapName)
                .WithColumnNames("MultiMapName1", "MultiMapName2", "MultiMapName3")
                .WithElementMap(e => e
                    .WithEmptyFallback(-1)
                    .WithInvalidFallback(-2)
                );

            Map<string>(p => p.MultiMapIndex)
                .WithColumnIndices(3, 4);

            Map(p => p.IEnumerableInt)
                .WithColumnNames(new List<string> { "IEnumerableInt1", "IEnumerableInt2" })
                .WithElementMap(e => e
                    .WithValueFallback(default(int))
                );

            Map(p => p.ICollectionBool)
                .WithColumnIndices(new List<int> { 7, 8 })
                .WithElementMap(e => e
                    .WithValueFallback(default(bool))
                );

            Map(p => p.IListString)
                .WithColumnNames("IListString1", "IListString2");

            Map(p => p.ListString)
                .WithColumnNames("ListString1", "ListString2");

            Map(p => (ICollection<string>)p._concreteICollection)
                .WithColumnNames("ListString1", "ListString2");

            Map<string>(p => p.CollectionString)
                .WithColumnNames("ListString1", "ListString2");

            Map<string>(p => p.ObservableCollectionString)
                .WithColumnNames("ListString1", "ListString2");

            Map<string>(p => p.CustomObservableCollectionString)
                .WithColumnNames("ListString1", "ListString2");

            Map<ObservableCollectionEnum>(p => p.CustomObservableCollectionEnum)
                .WithColumnNames("MultiMapIndex1", "MultiMapIndex2")
                .WithElementMap(e => e
                    .WithValueFallback(ObservableCollectionEnum.custom)
                );
        }
    }

    public interface INonGenericInteface { }
    public interface IGenericInterface<T> { }
    public interface IMultipleGenericInterface<T, U>{ }

    public class CustomList : INonGenericInteface, IGenericInterface<CustomList>, IList<string>, IMultipleGenericInterface<string, int>
    {
        private IList<string> Inner { get; } = new List<string>();

        public string this[int index]
        {
            get => Inner[0];
            set => Inner[0] = value;
        }

        public int Count => Inner.Count;

        public bool IsReadOnly => Inner.IsReadOnly;

        public void Add(string item) => Inner.Add(item);

        public void Clear() => Inner.Clear();

        public bool Contains(string item) => Inner.Contains(item);

        public void CopyTo(string[] array, int arrayIndex) => Inner.CopyTo(array, arrayIndex);

        public IEnumerator<string> GetEnumerator() => Inner.GetEnumerator();

        public int IndexOf(string item) => Inner.IndexOf(item);

        public void Insert(int index, string item) => Inner.Insert(index, item);

        public bool Remove(string item) => Inner.Remove(item);

        public void RemoveAt(int index) => Inner.RemoveAt(index);

        IEnumerator IEnumerable.GetEnumerator() => Inner.GetEnumerator();
    }

    private class CustomObservableCollection : ObservableCollection<string>
    {
    }

    private class CustomEnumObservableCollection : ObservableCollection<ObservableCollectionEnum>
    {
    }

    private enum ObservableCollectionEnum
    {
        a,
        b,
        custom
    }
}
